import express from 'express';
import multer from 'multer';
import fs from 'node:fs';
import path from 'node:path';
import { parseFilesToLogEntries } from '../services/ingest.js';
import { analyzeWithLLM } from '../services/llmAnalyzer.js';
import { analyzeLogs } from '../services/issueAnalyzer.js';
import { calculateUXScore } from '../services/scoreCalculator.js';

const router = express.Router();

// KIRO-AI: Configuration multer pour upload de fichiers
// Limite: 25MB par fichier, max 10 fichiers simultanés
// Stockage temporaire dans tmp/ (nettoyé après traitement)
const upload = multer({
  dest: 'tmp/',
  limits: {
    fileSize: 25 * 1024 * 1024, // 25MB
    files: 10,
  },
  fileFilter: (req, file, cb) => {
    // KIRO-AI: Accepter tous les formats de logs courants
    const allowedExts = [
      'json', 'ndjson', 'jsonl', 'log', 'csv', 'xml', 
      'html', 'htm', 'har', 'txt'
    ];
    const ext = file.originalname.split('.').pop().toLowerCase();
    
    if (allowedExts.includes(ext)) {
      cb(null, true);
    } else {
      cb(new Error(`Format non supporté: .${ext}`));
    }
  },
});

/**
 * POST /api/upload - Upload et analyse de fichiers logs
 * 
 * Pipeline:
 * 1. Parse multi-formats → LogEntry[]
 * 2. Tente analyse LLM (KAT-Coder-Pro)
 * 3. Fallback heuristique locale si LLM indisponible
 * 4. Nettoie les fichiers temporaires
 * 
 * @returns {Object} { report: { source, summary, stats, clusters, topIssues, recommendations, issues? } }
 */
// KIRO-AI: Route principale d'upload avec analyse intelligente
// Bascule automatiquement sur l'analyse locale si le quota OpenRouter est atteint
router.post('/api/upload', upload.array('files', 10), async (req, res) => {
  const uploadedFiles = req.files;
  
  try {
    // KIRO-AI: Validation des fichiers uploadés
    if (!uploadedFiles || uploadedFiles.length === 0) {
      return res.status(400).json({
        error: {
          message: 'Aucun fichier fourni',
          code: 'NO_FILES',
          timestamp: new Date().toISOString(),
        },
      });
    }

    console.log(`[KIRO-AI] Processing ${uploadedFiles.length} file(s)...`);

    // KIRO-AI: Étape 1 - Ingestion et normalisation multi-formats
    const entries = await parseFilesToLogEntries(uploadedFiles);
    
    if (entries.length === 0) {
      return res.status(400).json({
        error: {
          message: 'Aucune entrée de log valide trouvée dans les fichiers',
          code: 'NO_VALID_ENTRIES',
          timestamp: new Date().toISOString(),
        },
      });
    }

    console.log(`[KIRO-AI] Parsed ${entries.length} log entries`);

    // KIRO-AI: Étape 2 - Tentative d'analyse LLM (PRIORITÉ ABSOLUE)
    console.log('[KIRO-AI] Attempting LLM analysis with KAT-Coder-Pro...');
    let report = await analyzeWithLLM(entries);

    // KIRO-AI: Étape 3 - Fallback heuristique locale UNIQUEMENT si LLM indisponible
    if (!report) {
      console.warn('[KIRO-AI] ⚠️ LLM unavailable - falling back to local heuristic analysis');
      
      const localIssues = await analyzeLogs(entries);
      
      // KIRO-AI: Construire un rapport fallback structuré
      // Agrégation des stats par type et sévérité
      const byType = {};
      const bySeverity = { high: 0, medium: 0, low: 0 };
      
      localIssues.forEach(issue => {
        byType[issue.type] = (byType[issue.type] || 0) + 1;
        bySeverity[issue.severity] = (bySeverity[issue.severity] || 0) + 1;
      });

      report = {
        source: 'fallback-local',
        summary: `⚠️ Report generated by local heuristics (LLM unavailable). ${localIssues.length} issue(s) detected: ${bySeverity.high} critical, ${bySeverity.medium} medium, ${bySeverity.low} minor.`,
        stats: {
          total: localIssues.length,
          byType,
          bySeverity,
        },
        clusters: [],
        topIssues: [],
        recommendations: [
          {
            summary: 'Reduce loading time (LCP < 2.5s)',
            rationale: 'Users abandon if loading exceeds 3 seconds',
            references: ['Web Vitals – LCP'],
          },
          {
            summary: 'Fix accessibility issues (alt text, ARIA, keyboard)',
            rationale: 'WCAG 2.2 Level AA compliance required for universal accessibility',
            references: ['WCAG 2.2 – 1.1.1', 'WCAG 2.2 – 4.1.2', 'WCAG 2.2 – 2.1.1'],
          },
          {
            summary: 'Improve color contrast (ratio ≥ 4.5:1)',
            rationale: 'Insufficient contrast makes content unreadable for visually impaired users',
            references: ['WCAG 2.2 – 1.4.3'],
          },
        ],
        issues: localIssues, // Fallback: inclure les issues locales
      };
    } else {
      console.log(`[KIRO-AI] ✅ LLM analysis complete: ${report.stats?.total || 0} issues detected`);
    }

    // KIRO-AI: Calculate UX score based on detected issues
    const issuesToScore = report.topIssues || report.issues || [];
    report.uxScore = calculateUXScore(issuesToScore);
    console.log(`[KIRO-AI] UX Score calculated: ${report.uxScore}/100`);

    // KIRO-AI: Étape 4 - Nettoyage des fichiers temporaires
    uploadedFiles.forEach(file => {
      try {
        fs.unlinkSync(file.path);
      } catch (error) {
        console.warn(`[KIRO-AI] Failed to delete temp file ${file.path}:`, error.message);
      }
    });

    // KIRO-AI: Réponse structurée avec le rapport
    res.json({ report });
  } catch (error) {
    // KIRO-AI: Gestion d'erreurs avec nettoyage des fichiers
    console.error('[KIRO-AI] Upload error:', error);
    
    // Nettoyer les fichiers en cas d'erreur
    if (uploadedFiles) {
      uploadedFiles.forEach(file => {
        try {
          fs.unlinkSync(file.path);
        } catch (err) {
          // Ignorer les erreurs de nettoyage
        }
      });
    }

    // Erreur de taille de fichier
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(413).json({
        error: {
          message: 'Fichier trop volumineux (limite: 25MB)',
          code: 'FILE_TOO_LARGE',
          timestamp: new Date().toISOString(),
        },
      });
    }

    // Erreur générique
    res.status(500).json({
      error: {
        message: 'Erreur lors du traitement des fichiers',
        code: 'UPLOAD_FAILED',
        details: error.message,
        timestamp: new Date().toISOString(),
      },
    });
  }
});

export default router;
